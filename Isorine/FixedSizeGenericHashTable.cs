using System;
using System.Collections;
using System.IO;
using System.Text;

namespace Isorine
{
    public class FixedSizeGenericHashTable
    {
        string path = System.IO.Directory.GetCurrentDirectory() + "\\list";
        private readonly int size;
        //private readonly LinkedList<KeyValue<K, V>>[] items;
        private readonly string[] items;

        public FixedSizeGenericHashTable(int size)
        {
            this.size = size;
            //items = new LinkedList<KeyValue<K, V>>[size];
            items = new string[size];
        }
        /// <summary>
        /// Finds if there is such a key in file
        /// </summary>
        /// <param name="key">specified key</param>
        /// <returns>true if there is a match fase if there isin't</returns>
        public Boolean FileContains(string key)
        {
            int position = GetArrayPosition(key);
            string filename = GetLinkedList(position);

            if (filename == "" || filename == null)
                return false;
            Byte[] Bkey = new UTF8Encoding(true).GetBytes(key);
            int start = 0;
            int end = 4;
            //BitConverter.GetBytes(v.dataFloat).CopyTo(dataFloat, 4);
            using (var fs = new FileStream(filename, FileMode.Open))
            {
                Byte[] readed = new byte[4];
                for (int i = 0; i < fs.Length / 8; i++)
                {
                    fs.Read(readed, start, end);
                    string foundkey = Encoding.UTF8.GetString(readed, 0, readed.Length);
                    if (foundkey.Equals(key))
                        return true;
                start +=8;
                end += 8;
                }
                
            }
            return false;
        }
        /// <summary>
        /// gets array possition from hashcode
        /// </summary>
        /// <param name="key">key</param>
        /// <returns>position</returns>
        protected int GetArrayPosition(string key)
        {
            int position = key.GetHashCode() % size;
            return Math.Abs(position);
        }
        /// <summary>
        /// finds value by specific key
        /// </summary>
        /// <param name="key">key</param>
        /// <returns>value</returns>
        public float FindValue(string key)
        {
            int position = GetArrayPosition(key);
            string filename = GetLinkedList(position);

            if (filename == "" || filename == null)
                return 0;
           Byte[] Bkey = new UTF8Encoding(true).GetBytes(key);
            int start = 0;
            int end = 4;
            //BitConverter.GetBytes(v.dataFloat).CopyTo(dataFloat, 4);
            using (var fs = new FileStream(filename, FileMode.Open))
            {
                Byte[] readed = new byte[4];
                for (int i = 0; i < fs.Length / 8; i++)
                {
                    fs.Read(readed, start, end);

                    if (ByteArrayCompare(readed, Bkey))
                    {
                        Byte[] value = new byte[4];
                        fs.Read(value, start, end);
                        return System.BitConverter.ToSingle(value, 0);

                    }
                    start += 8;
                    end += 8;
                }
            }
            return 0;
        }
        /// <summary>
        /// compares two byte arrays
        /// </summary>
        /// <param name="a1">byte array</param>
        /// <param name="a2">byte array</param>
        /// <returns>true if they match false if they don't</returns>
        static bool ByteArrayCompare(byte[] a1, byte[] a2)
        {
            return StructuralComparisons.StructuralEqualityComparer.Equals(a1, a2);
        }
        /// <summary>
        /// Creates file if there isin't one with specific name generated by key's
        /// hashcode if there is one then appends that file with new key and value
        /// </summary>
        /// <param name="key">key</param>
        /// <param name="value">value</param>
        public void Add(string key, float value)
        {
            string fileName =path+"\\"+key.GetHashCode()+".dat";
            
            if (File.Exists(fileName))
            {
                using (var stream = new FileStream(fileName, FileMode.Append))
                {
                    byte[] bytes = new UTF8Encoding(true).GetBytes(key);
                    byte[] valuebytes = BitConverter.GetBytes(value);
                    stream.Write(bytes, 0, bytes.Length);
                    stream.Write(valuebytes, 0, valuebytes.Length);
                }
            }
            else
            {
                // Create a new file     
                using (FileStream fs = File.Create(fileName))
                {
                    // Add some text to file    
                    byte[] skey = new UTF8Encoding(true).GetBytes(key);
                    fs.Write(skey, 0, 4);
                    byte[] svalue = BitConverter.GetBytes(value);
                    fs.Write(svalue, 0, 4);
                }
                items[GetArrayPosition(key)] = fileName;
            }
            
        }
        /// <summary>
        /// Removes key and value from file
        /// </summary>
        /// <param name="key">key</param>
        public void Remove(string key)
        {
            int position = GetArrayPosition(key);
            string filename = GetLinkedList(position);
            if (filename == "" || filename == null)
                return;

            Byte[] Bkey = new UTF8Encoding(true).GetBytes(key);
            int start = 0;
            int end = 4;
            Byte[] readed = new byte[4];
            bool detected = false;
            int startingpos=0;
            int lenghtofFs=0;
            using (var fs = new FileStream(filename, FileMode.Open))
            {
                for (int i = 0; i < fs.Length / 8; i++)
                {
                    fs.Read(readed, start, end);

                    if (ByteArrayCompare(readed, Bkey))
                    {
                        detected = true;
                        lenghtofFs = Convert.ToInt32(fs.Length);
                        startingpos = start;
                    }
                    start = start+8;
                    end = end + 8;
                }
            }
            if (detected)
            {
                Byte[] starting = new Byte[startingpos];
                Byte[] ending = new Byte[lenghtofFs-(startingpos+8)];
                using (var fs = new FileStream(filename, FileMode.Open))
                {
                    if(startingpos>0)
                    fs.Read(starting, 0, startingpos);
                    if(Convert.ToInt32(fs.Length) - (startingpos + 8)>0)
                    fs.Read(ending, starting.Length + 8, Convert.ToInt32(fs.Length) - (startingpos + 8));
                }
                File.Delete(filename);
                using (FileStream fs = File.Create(filename))
                {
                    // Add some text to file   
                    if (startingpos > 0)
                        fs.Write(starting, 0, starting.Length);
                    if (Convert.ToInt32(fs.Length) - (startingpos + 8) > 0)
                        fs.Write(ending, starting.Length + 8, ending.Length);
                }
            }

        }

        private string GetLinkedList(int position)
        {
            string linkedList = items[position];
            if (linkedList == null)
            {
                linkedList = "";
                items[position] = linkedList;
            }

            return linkedList;
        }
    }
}